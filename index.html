<!DOCTYPE html>
<html lang="en">

<head>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-9X1ZY32STV"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());

        gtag('config', 'G-9X1ZY32STV');

    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no">
    <title>Numatics</title>
    <link rel="icon" type="image/x-icon" href="/images/favicon.ico">
    <meta property="og:image" content="/images/featured.jpg">
    <meta property="og:title" content="Numatics">
    <meta property="og:description" content="Wave interactions with shapes and forms.">
    <meta property="og:url" content="https://www.numatics.world">
    <meta property="og:type" content="website">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Jockey+One&family=League+Spartan:wght@100..900&family=Lora:ital,wght@0,400..700;1,400..700&family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/svg-path-properties@1.1.1/dist/svg-path-properties.min.js"></script>
    <style>
        /* CSS variables for centralized color theming */
        :root {
            --bg: #111827;
            --panel-bg: #1f2937;
            --text: #f3f4f6;
            --text-muted: #d1d5db;
            --primary: #3b82f6;
            --secondary: #4b5563;
            --accent: #ec4899;
            --slider-track: #374151;
        }

        body {
            font-family: "League Spartan", sans-serif;
            background-color: var(--bg);
            color: var(--text);
        }

        /* Start by hiding the modal */
        #simple-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            /* Dark semi-transparent background */
        }

        .modal-content {
            background-color: var(--panel-bg);
            margin: 20% auto;
            padding: 20px;
            border-radius: 5px;
            width: 90%;
            max-width: 400px;
            text-align: center;
        }

        .close-btn {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-btn:hover {
            color: var(--text);
        }

        .control-panel {
            background-color: var(--panel-bg);
            border-right: 1px solid #374151;
        }

        .control-group {
            border-bottom: 1px solid #374151;
            padding: 1rem;
        }

        .control-group:last-child {
            border-bottom: none;
        }

        .aboutSection {
            position: absolute;
            left: 10px;
            bottom: 10px;
            padding: 20px;
            background-color: var(--panel-bg);
            color: #aaa;
            font-size: 10px;
        }

        a:link {
            color: var(--accent);
            background-color: transparent;
            text-decoration: none;
        }

        label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--text-muted);
        }

        input[type="range"] {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 0.5rem;
            background-color: var(--slider-track);
            border-radius: 9999px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1rem;
            height: 1rem;
            background-color: var(--primary);
            border-radius: 9999px;
        }

        button,
        .file-upload-label {
            display: inline-block;
            width: 100%;
            padding: 0.6rem 1rem;
            background-color: var(--primary);
            color: white;
            border-radius: 0.375rem;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
            transition: filter 0.2s;
        }

        button:hover,
        .file-upload-label:hover {
            filter: brightness(0.85);
        }

        .btn-primary {
            background-color: var(--primary);
        }

        .btn-primary:hover {
            filter: brightness(0.85);
        }


        .btn-secondary {
            background-color: var(--secondary);
        }

        .btn-secondary:hover {
            filter: brightness(1.2);
        }

        /* Style for the new palette selector */
        select {
            width: 100%;
            padding: 0.6rem;
            background-color: var(--slider-track);
            color: var(--text);
            border: 1px solid var(--secondary);
            border-radius: 0.375rem;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: var(--primary);
        }


        #canvas-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            border-radius: 0.5rem;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #logo {
            width: 25%;
            margin: auto;
        }

        @media (max-width: 768px) {
            #canvas-container {
                height: 50vh;
            }

            .control-panel {
                height: 50vh;
                padding: 30px;
                padding-top: 0px;
            }

            #logo {
                width: 10%;
            }
        }

    </style>
</head>

<body class="flex flex-col md:flex-row h-screen">
    <main id="canvas-container">
    </main>
    <div id="simple-modal">
        <div class="modal-content">
            <span class="close-btn">&times;</span>
            <p style="font-size: 20px;font-weight: 700">Best Viewed on Desktop</p>
            <p style="font-size: 14px;font-weight: 200">For the best experience, please use a desktop or laptop computer.
            </p>
        </div>
    </div>
    <div class="control-panel w-full md:w-80 flex-shrink-0 overflow-y-auto">
        <div class="p-4 text-center border-b border-gray-700">
            <img id="logo" src="images/logo.png">
            <h1 class="text-xl font-bold text-white">Numatics</h1>
            <p class="text-xs text-gray-400">Wave interactions with shapes and forms</p>
        </div>

        <div class="control-group">
            <label>Preset Shape Boundaries (SVG)</label>
            <div class="grid grid-cols-2 gap-2">
                <button class="svg-load-button btn-secondary" data-svg-path="SVG/none.svg">None</button>
                <button class="svg-load-button btn-secondary" data-svg-path="SVG/human.svg">Human</button>
                <button class="svg-load-button btn-secondary" data-svg-path="SVG/infinity.svg">Infinity</button>
                <button class="svg-load-button btn-secondary" data-svg-path="SVG/clover.svg">Clover</button>
            </div>
        </div>

        <div class="control-group">
            <label for="svgFile">Import Custom SVG Boundary</label>
            <input type="file" id="svgFile" class="hidden" accept=".svg">
            <label for="svgFile" class="file-upload-label">Select SVG File</label>
        </div>

        <div class="control-group">
            <label for="sidesSlider">Outer Boundary: <span id="sidesValue">6</span></label>
            <input type="range" id="sidesSlider" min="3" max="13" value="6">
        </div>

        <div class="control-group">
            <label for="strengthSlider">Feedback Strength: <span id="strengthValue">0.5</span></label>
            <input type="range" id="strengthSlider" min="0.01" max="1.0" value="0.5" step="0.01">
        </div>

        <div class="control-group">
            <label for="dampingSlider">Damping (1 = No Friction): <span id="dampingValue">1.000</span></label>
            <input type="range" id="dampingSlider" min="0.95" max="1.0" value="1.0" step="0.001">
        </div>

        <div class="control-group">
            <label for="speedSlider">Speed: <span id="speedValue">3</span></label>
            <input type="range" id="speedSlider" min="1" max="20" value="3">
        </div>

        <div class="control-group">
            <label for="svgScaleSlider">SVG Scale: <span id="svgScaleValue">0.4</span></label>
            <input type="range" id="svgScaleSlider" min="0.1" max="1.5" value="0.4" step="0.05">
        </div>

        <div class="control-group">
            <label for="nudgeSlider">Nudge Amount: <span id="nudgeValue">250</span></label>
            <input type="range" id="nudgeSlider" min="50" max="500" value="250">
        </div>

        <div class="control-group">
            <label for="nudgeRadiusSlider">Nudge Radius: <span id="nudgeRadiusValue">15</span></label>
            <input type="range" id="nudgeRadiusSlider" min="2" max="50" value="15">
        </div>

        <div class="control-group grid grid-cols-2 gap-2">
            <button id="centerPulseButton" class="btn-primary">Center Pulse</button>
            <button id="clearButton" class="btn-secondary">Clear All</button>
        </div>
        <div class="control-group">
            <label for="paletteSelector">Color Palette</label>
            <select id="paletteSelector">
            </select>
        </div>
        <div class="aboutSection">
            <p>An Open-Source project by <a href="https://nurecas.com/AbouT-Me">Fabin Rasheed</a></p>
            <p>Github: <a href="https://github.com/nurecas/numatics/">Numatics Github</a></p>
            <p>Share feedback: <a href="https://nurecas.com/Contact">Contact page</a></p>
        </div>
    </div>


    <script>
        // 1. Get the elements
        const modal = document.getElementById('simple-modal');
        const abt = document.querySelector('.aboutSection');
        const closeBtn = document.querySelector('.close-btn');

        // 2. Define the mobile breakpoint (768px is common for tablets/mobile)
        const isMobile = window.matchMedia('(max-width: 768px)').matches;

        // 3. Show the modal if the screen is small
        if (isMobile) {
            modal.style.display = 'block';
            abt.style.display = 'none';
        }

        // 4. Close the modal when the 'X' is clicked
        closeBtn.onclick = function() {
            modal.style.display = 'none';
        }

        // 5. Close the modal if the user clicks the dark background
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = 'none';
            }
        }


        const sketch = (p) => {
            // --- Simulation State Variables ---
            let value, velocity, velocityBuffer; // OPTIMIZED: Added velocityBuffer for swapping
            let feedbackStrength = 0.5;
            let damping = 1.0;
            let nudgeAmount = 250;
            let nudgeRadius = 15;
            let speed = 3;

            // --- Boundary State Variables ---
            let outerBoundaryVertices = [];
            let numSides = 6;
            let svgScale = 0.4;
            let rawSvgSegments = [];
            let scaledSvgSegments = [];
            let svgMask, boundaryMask; // OPTIMIZED: Added boundaryMask
            const PADDING = 100;

            let canvasWidth, canvasHeight;

            // --- Color Palette State ---
            let colorPalettes = [];
            let currentPalette;

            // --- UI Element Cache ---
            // OPTIMIZED: Caching DOM elements for faster access
            const ui = {};

            p.setup = () => {
                const container = document.getElementById('canvas-container');
                const canvas = p.createCanvas(container.clientWidth, container.clientHeight);
                canvas.parent(container);
                canvasWidth = p.width;
                canvasHeight = p.height;
                p.pixelDensity(1);

                initializeGrids();

                initializeColorPalettes();
                currentPalette = colorPalettes[0]; // Set default

                cacheUIElements(); // OPTIMIZED: Cache elements once
                applyPalette(); // Apply default palette
                setupUIListeners();
                updateOuterBoundary(); // This will now also update the boundaryMask
                updateDisplay();
            };

            p.draw = () => {
                for (let i = 0; i < speed; i++) {
                    propagateWave();
                }
                updateDisplay();
                drawBoundaryOutline();
                drawSvgOutline();
            };

            function initializeColorPalettes() {
                colorPalettes = [{
                        name: "Numatics Blue",
                        css: {
                            '--bg': "#111827",
                            '--panel-bg': "#1f2937",
                            '--text': "#f3f4f6",
                            '--text-muted': "#d1d5db",
                            '--primary': "#3b82f6",
                            '--secondary': "#4b5563",
                            '--accent': "#ec4899",
                            '--slider-track': "#374151"
                        },
                        p5: {
                            bg: [17, 24, 39],
                            boundary: [59, 130, 246, 150],
                            svg: [236, 72, 153, 200],
                            crest_mix: [1.0, 1.0, 0.5],
                            trough_mix: [0.2, 0.6, 1.0]
                        }
                    },
                    {
                        name: "Solar Flare",
                        css: {
                            '--bg': "#200000",
                            '--panel-bg': "#400000",
                            '--text': "#ffe5e5",
                            '--text-muted': "#ffc0c0",
                            '--primary': "#ff4500",
                            '--secondary': "#8b0000",
                            '--accent': "#00ff00",
                            '--slider-track': "#600000"
                        },
                        p5: {
                            bg: [32, 0, 0],
                            boundary: [255, 69, 0, 150],
                            svg: [0, 255, 0, 200],
                            crest_mix: [1.0, 0.8, 0.0],
                            trough_mix: [0.8, 0.0, 0.0]
                        }
                    },
                    {
                        name: "Deep Sea",
                        css: {
                            '--bg': "#031a2c",
                            '--panel-bg': "#0a2f4d",
                            '--text': "#e0f7ff",
                            '--text-muted': "#b3ecff",
                            '--primary': "#00e5ff",
                            '--secondary': "#008c9e",
                            '--accent': "#f0ff00",
                            '--slider-track': "#07416d"
                        },
                        p5: {
                            bg: [3, 26, 44],
                            boundary: [0, 229, 255, 150],
                            svg: [240, 255, 0, 200],
                            crest_mix: [0.0, 1.0, 0.5],
                            trough_mix: [0.5, 0.0, 1.0]
                        }
                    },
                    {
                        name: "Monochrome",
                        css: {
                            '--bg': "#111111",
                            '--panel-bg': "#222222",
                            '--text': "#eeeeee",
                            '--text-muted': "#cccccc",
                            '--primary': "#007acc",
                            '--secondary': "#555555",
                            '--accent': "#ffffff",
                            '--slider-track': "#444444"
                        },
                        p5: {
                            bg: [17, 17, 17],
                            boundary: [0, 122, 204, 150],
                            svg: [255, 255, 255, 200],
                            crest_mix: [1.0, 1.0, 1.0],
                            trough_mix: [0.5, 0.5, 0.5]
                        }
                    },
                    {
                        name: "Forest Mist",
                        css: {
                            '--bg': "#0a1a0f",
                            '--panel-bg': "#1a3a2a",
                            '--text': "#e6f5e9",
                            '--text-muted': "#c0e0c8",
                            '--primary': "#4ade80",
                            '--secondary': "#166534",
                            '--accent': "#7dd3fc",
                            '--slider-track': "#14532d"
                        },
                        p5: {
                            bg: [10, 26, 15],
                            boundary: [74, 222, 128, 150],
                            svg: [125, 211, 252, 200],
                            crest_mix: [0.5, 1.0, 0.5],
                            trough_mix: [0.2, 0.5, 1.0]
                        }
                    },
                    {
                        name: "Synthwave",
                        css: {
                            '--bg': "#1a0b2e",
                            '--panel-bg': "#2e1a47",
                            '--text': "#f5e6ff",
                            '--text-muted': "#e0c0ff",
                            '--primary': "#f472b6",
                            '--secondary': "#86198f",
                            '--accent': "#2dd4bf",
                            '--slider-track': "#4a2c6d"
                        },
                        p5: {
                            bg: [26, 11, 46],
                            boundary: [244, 114, 182, 150],
                            svg: [45, 212, 191, 200],
                            crest_mix: [1.0, 0.5, 1.0],
                            trough_mix: [0.5, 0.2, 1.0]
                        }
                    },
                    {
                        name: "Golden Hour",
                        css: {
                            '--bg': "#2a1a00",
                            '--panel-bg': "#4a3a1f",
                            '--text': "#fffbeb",
                            '--text-muted': "#fef3c7",
                            '--primary': "#facc15",
                            '--secondary': "#9a3412",
                            '--accent': "#a5f3fc",
                            '--slider-track': "#78350f"
                        },
                        p5: {
                            bg: [42, 26, 0],
                            boundary: [250, 204, 21, 150],
                            svg: [165, 243, 252, 200],
                            crest_mix: [1.0, 0.8, 0.2],
                            trough_mix: [0.8, 0.2, 0.0]
                        }
                    }
                ];
            }

            function applyPalette() {
                const cssProps = currentPalette.css;
                for (const prop in cssProps) {
                    document.documentElement.style.setProperty(prop, cssProps[prop]);
                }
                // p5 colors are read directly from currentPalette in draw loops
            }


            function initializeGrids() {
                value = [];
                velocity = [];
                velocityBuffer = []; // OPTIMIZED
                svgMask = [];
                boundaryMask = []; // OPTIMIZED

                for (let y = 0; y < canvasHeight; y++) {
                    value[y] = new Float32Array(canvasWidth).fill(0);
                    velocity[y] = new Float32Array(canvasWidth).fill(0);
                    velocityBuffer[y] = new Float32Array(canvasWidth).fill(0); // OPTIMIZED
                    svgMask[y] = new Uint8Array(canvasWidth).fill(0);
                    boundaryMask[y] = new Uint8Array(canvasWidth).fill(0); // OPTIMIZED
                }
            }

            p.mousePressed = () => {
                if (p.mouseX > 0 && p.mouseX < p.width && p.mouseY > 0 && p.mouseY < p.height) {
                    nudge(p.mouseX, p.mouseY, nudgeAmount, nudgeRadius);
                }
            };

            p.windowResized = () => {
                const container = document.getElementById('canvas-container');
                p.resizeCanvas(container.clientWidth, container.clientHeight);
                canvasWidth = p.width;
                canvasHeight = p.height;
                initializeGrids();
                updateOuterBoundary(); // This now regenerates the mask
                generateSvgMask();
            };

            function clearSystem() {
                for (let y = 0; y < canvasHeight; y++) {
                    value[y].fill(0);
                    velocity[y].fill(0);
                    velocityBuffer[y].fill(0); // OPTIMIZED: Clear the buffer too
                }
            }

            // OPTIMIZED: Function to cache all UI elements
            function cacheUIElements() {
                ui.paletteSelector = document.getElementById('paletteSelector');
                ui.sidesSlider = document.getElementById('sidesSlider');
                ui.sidesValue = document.getElementById('sidesValue');
                ui.svgFile = document.getElementById('svgFile');
                ui.strengthSlider = document.getElementById('strengthSlider');
                ui.strengthValue = document.getElementById('strengthValue');
                ui.dampingSlider = document.getElementById('dampingSlider');
                ui.dampingValue = document.getElementById('dampingValue');
                ui.speedSlider = document.getElementById('speedSlider');
                ui.speedValue = document.getElementById('speedValue');
                ui.svgScaleSlider = document.getElementById('svgScaleSlider');
                ui.svgScaleValue = document.getElementById('svgScaleValue');
                ui.nudgeSlider = document.getElementById('nudgeSlider');
                ui.nudgeValue = document.getElementById('nudgeValue');
                ui.nudgeRadiusSlider = document.getElementById('nudgeRadiusSlider');
                ui.nudgeRadiusValue = document.getElementById('nudgeRadiusValue');
                ui.centerPulseButton = document.getElementById('centerPulseButton');
                ui.clearButton = document.getElementById('clearButton');
                ui.svgLoadButtons = document.querySelectorAll('.svg-load-button');

                // Populate the palette selector
                colorPalettes.forEach(palette => {
                    const option = document.createElement('option');
                    option.value = palette.name;
                    option.textContent = palette.name;
                    ui.paletteSelector.appendChild(option);
                });
            }

            function setupUIListeners() {
                ui.paletteSelector.addEventListener('change', (e) => {
                    const selectedName = e.target.value;
                    currentPalette = colorPalettes.find(p => p.name === selectedName);
                    applyPalette();
                });
                ui.sidesSlider.addEventListener('input', (e) => {
                    numSides = parseInt(e.target.value);
                    ui.sidesValue.textContent = numSides > 12 ? 'Circle' : numSides;
                    updateOuterBoundary();
                });
                ui.svgFile.addEventListener('change', handleSVGUpload);
                ui.svgLoadButtons.forEach(button => {
                    button.addEventListener('click', (e) => loadSVGFromPath(e.target.dataset.svgPath));
                });
                ui.strengthSlider.addEventListener('input', (e) => {
                    feedbackStrength = parseFloat(e.target.value);
                    ui.strengthValue.textContent = feedbackStrength.toFixed(2);
                });
                ui.dampingSlider.addEventListener('input', (e) => {
                    damping = parseFloat(e.target.value);
                    ui.dampingValue.textContent = damping.toFixed(3);
                });
                ui.speedSlider.addEventListener('input', (e) => {
                    speed = parseInt(e.target.value);
                    ui.speedValue.textContent = speed;
                });
                ui.svgScaleSlider.addEventListener('input', (e) => {
                    svgScale = parseFloat(e.target.value);
                    ui.svgScaleValue.textContent = svgScale.toFixed(2);
                    generateSvgMask();
                });
                ui.nudgeSlider.addEventListener('input', e => {
                    nudgeAmount = parseInt(e.target.value);
                    ui.nudgeValue.textContent = nudgeAmount;
                });
                ui.nudgeRadiusSlider.addEventListener('input', e => {
                    nudgeRadius = parseInt(e.target.value);
                    ui.nudgeRadiusValue.textContent = nudgeRadius;
                });
                ui.centerPulseButton.addEventListener('click', () => {
                    nudge(p.width / 2, p.height / 2, nudgeAmount, nudgeRadius);
                });
                ui.clearButton.addEventListener('click', clearSystem);
            }

            // OPTIMIZED: This function is now only used to generate the mask.
            function isInBoundary(x, y, vertices) {
                let inside = false;
                for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
                    const xi = vertices[i].x,
                        yi = vertices[i].y;
                    const xj = vertices[j].x,
                        yj = vertices[j].y;
                    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }

            // OPTIMIZED: New function to generate the boundary mask once.
            function updateBoundaryMask() {
                for (let y = 0; y < canvasHeight; y++) {
                    for (let x = 0; x < canvasWidth; x++) {
                        boundaryMask[y][x] = isInBoundary(x, y, outerBoundaryVertices) ? 0 : 1;
                    }
                }
            }

            function updateOuterBoundary() {
                outerBoundaryVertices = [];
                const center = {
                    x: p.width / 2,
                    y: p.height / 2
                };
                const radius = p.min(p.width, p.height) / 2 - 10;
                const isCircle = numSides > 12;
                const sides = isCircle ? 100 : numSides;
                const angleOffset = isCircle ? 0 : p.PI / sides;
                for (let i = 0; i < sides; i++) {
                    const angle = i * (2 * p.PI / sides) - p.PI / 2 + angleOffset;
                    outerBoundaryVertices.push({
                        x: center.x + radius * p.cos(angle),
                        y: center.y + radius * p.sin(angle)
                    });
                }
                updateBoundaryMask(); // OPTIMIZED: Update the mask whenever the boundary changes.
            }

            function drawBoundaryOutline() {
                p.stroke(...currentPalette.p5.boundary);
                p.strokeWeight(2);
                p.noFill();
                p.beginShape();
                for (const v of outerBoundaryVertices) {
                    p.vertex(v.x, v.y);
                }
                p.endShape(p.CLOSE);
            }

            function drawSvgOutline() {
                if (scaledSvgSegments.length === 0) return;
                p.stroke(...currentPalette.p5.svg);
                p.strokeWeight(2);
                p.noFill();
                for (const seg of scaledSvgSegments) {
                    p.line(seg.x1, seg.y1, seg.x2, seg.y2);
                }
            }

            function nudge(x, y, amount, radius) {
                const floorX = Math.floor(x),
                    floorY = Math.floor(y);
                const rSquared = radius * radius;
                for (let dy = -radius; dy <= radius; dy++) {
                    for (let dx = -radius; dx <= radius; dx++) {
                        if (dx * dx + dy * dy > rSquared) continue;
                        const xx = floorX + dx,
                            yy = floorY + dy;
                        if (xx >= 0 && xx < canvasWidth && yy >= 0 && yy < canvasHeight) {
                            // OPTIMIZED: Fast mask check
                            if (boundaryMask[yy][xx] === 0 && svgMask[yy][xx] === 0) {
                                value[yy][xx] += amount;
                            }
                        }
                    }
                }
            }

            function propagateWave() {
                // OPTIMIZED: The velocityBuffer is used instead of creating a new array.
                for (let y = 1; y < canvasHeight - 1; y++) {
                    for (let x = 1; x < canvasWidth - 1; x++) {
                        // OPTIMIZED: Fast mask check
                        if (boundaryMask[y][x] === 1 || svgMask[y][x] === 1) {
                            continue;
                        }
                        const laplacian = (value[y + 1][x] + value[y - 1][x] + value[y][x + 1] + value[y][x - 1]) - 4 * value[y][x];
                        velocityBuffer[y][x] = (velocity[y][x] + laplacian * feedbackStrength) * damping;
                    }
                }

                // OPTIMIZED: Efficiently swap buffers, no new memory allocated.
                let temp = velocity;
                velocity = velocityBuffer;
                velocityBuffer = temp;

                for (let y = 0; y < canvasHeight; y++) {
                    for (let x = 0; x < canvasWidth; x++) {
                        // OPTIMIZED: Fast mask check
                        if (boundaryMask[y][x] === 1 || svgMask[y][x] === 1) {
                            value[y][x] = 0;
                            velocity[y][x] = 0;
                        } else {
                            value[y][x] += velocity[y][x];
                        }
                    }
                }
            }

            function updateDisplay() {
                p.loadPixels();
                const colorIntensity = 2.5;

                // Get colors from the active palette
                const [baseR, baseG, baseB] = currentPalette.p5.bg;
                const [crestR, crestG, crestB] = currentPalette.p5.crest_mix;
                const [troughR, troughG, troughB] = currentPalette.p5.trough_mix;


                for (let y = 0; y < canvasHeight; y++) {
                    for (let x = 0; x < canvasWidth; x++) {
                        const idx = 4 * (y * canvasWidth + x);

                        // OPTIMIZED: Fast mask check
                        if (boundaryMask[y][x] === 1 || svgMask[y][x] === 1) {
                            p.pixels[idx] = baseR;
                            p.pixels[idx + 1] = baseG;
                            p.pixels[idx + 2] = baseB;
                            p.pixels[idx + 3] = 255;
                            continue;
                        }

                        const v = value[y][x];
                        let r = baseR,
                            g = baseG,
                            b = baseB;

                        if (v > 0) {
                            r = p.min(255, baseR + v * colorIntensity * crestR);
                            g = p.min(255, baseG + v * colorIntensity * crestG);
                            b = p.min(255, baseB + v * colorIntensity * crestB);
                        } else {
                            r = p.min(255, baseR - v * colorIntensity * troughR);
                            g = p.min(255, baseG - v * colorIntensity * troughG);
                            b = p.min(255, baseB - v * colorIntensity * troughB);
                        }

                        p.pixels[idx] = r;
                        p.pixels[idx + 1] = g;
                        p.pixels[idx + 2] = b;
                        p.pixels[idx + 3] = 255;
                    }
                }
                p.updatePixels();
            }

            function loadSVGFromPath(path) {
                if (path.endsWith('none.svg')) {
                    rawSvgSegments = [];
                    generateSvgMask();
                    return;
                }
                fetch(path)
                    .then(response => response.ok ? response.text() : Promise.reject(
                        `HTTP error! status: ${response.status}`))
                    .then(parseSVG)
                    .catch(e => console.error('Error loading SVG:', e));
            }

            function handleSVGUpload(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => parseSVG(e.target.result);
                reader.readAsText(file);
            }

            function parseSVG(svgText) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(svgText, "image/svg+xml");
                rawSvgSegments = [];
                let minX = Infinity,
                    minY = Infinity,
                    maxX = -Infinity,
                    maxY = -Infinity;

                doc.querySelectorAll('path').forEach(path => {
                    const d = path.getAttribute('d');
                    if (!d) return;
                    try {
                        const properties = svgPathProperties.svgPathProperties(d);
                        const totalLength = properties.getTotalLength();
                        if (totalLength === 0) return;
                        const step = totalLength / Math.max(200, totalLength / 2);
                        let lastPoint = properties.getPointAtLength(0);
                        for (let i = step; i <= totalLength + 0.001; i += step) {
                            const point = properties.getPointAtLength(Math.min(i, totalLength));
                            rawSvgSegments.push({
                                start: lastPoint,
                                end: point
                            });
                            minX = Math.min(minX, lastPoint.x, point.x);
                            minY = Math.min(minY, lastPoint.y, point.y);
                            maxX = Math.max(maxX, lastPoint.x, point.x);
                            maxY = Math.max(maxY, lastPoint.y, point.y);
                            lastPoint = point;
                        }
                    } catch (e) {
                        console.error("Could not parse SVG path:", d, e);
                    }
                });

                rawSvgSegments.bounds = {
                    minX,
                    minY,
                    maxX,
                    maxY
                };
                generateSvgMask();
            }

            function generateSvgMask() {
                for (let y = 0; y < canvasHeight; y++) {
                    svgMask[y].fill(0);
                }
                scaledSvgSegments = [];

                if (rawSvgSegments.length === 0) return;

                const {
                    minX,
                    minY,
                    maxX,
                    maxY
                } = rawSvgSegments.bounds;
                const svgWidth = maxX - minX;
                const svgHeight = maxY - minY;
                if (svgWidth === 0 || svgHeight === 0) return;

                const canvasInnerWidth = p.width - PADDING * 2;
                const canvasInnerHeight = p.height - PADDING * 2;
                const baseScale = Math.min(canvasInnerWidth / svgWidth, canvasInnerHeight / svgHeight);
                const finalScale = baseScale * svgScale;
                const offsetX = (p.width / 2) - (svgWidth * finalScale / 2) - (minX * finalScale);
                const offsetY = (p.height / 2) - (svgHeight * finalScale / 2) - (minY * finalScale);

                const lineThickness = 3;
                const thicknessSq = lineThickness * lineThickness;

                for (const seg of rawSvgSegments) {
                    const x1 = seg.start.x * finalScale + offsetX;
                    const y1 = seg.start.y * finalScale + offsetY;
                    const x2 = seg.end.x * finalScale + offsetX;
                    const y2 = seg.end.y * finalScale + offsetY;

                    scaledSvgSegments.push({
                        x1,
                        y1,
                        x2,
                        y2
                    });

                    const min_x = Math.floor(Math.min(x1, x2)) - lineThickness;
                    const max_x = Math.ceil(Math.max(x1, x2)) + lineThickness;
                    const min_y = Math.floor(Math.min(y1, y2)) - lineThickness;
                    const max_y = Math.ceil(Math.max(y1, y2)) + lineThickness;

                    for (let y = min_y; y <= max_y; y++) {
                        for (let x = min_x; x <= max_x; x++) {
                            if (x < 0 || x >= canvasWidth || y < 0 || y >= canvasHeight) continue;
                            if (pointToSegmentDistanceSq(x, y, x1, y1, x2, y2) <= thicknessSq) {
                                svgMask[y][x] = 1;
                            }
                        }
                    }
                }
            }

            function pointToSegmentDistanceSq(px, py, x1, y1, x2, y2) {
                const l2 = (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);
                if (l2 == 0) return (px - x1) * (px - x1) + (py - y1) * (py - y1);
                let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
                t = Math.max(0, Math.min(1, t));
                const x = x1 + t * (x2 - x1);
                const y = y1 + t * (y2 - y1);
                return (px - x) * (px - x) + (py - y) * (py - y);
            }
        };
        new p5(sketch);

    </script>
</body>

</html>
